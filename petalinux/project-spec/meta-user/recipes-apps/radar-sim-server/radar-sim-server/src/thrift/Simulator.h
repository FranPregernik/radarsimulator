/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Simulator_H
#define Simulator_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "sim_types.h"

namespace hr { namespace franp { namespace rsim {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class SimulatorIf {
 public:
  virtual ~SimulatorIf() {}

  /**
   * Resets the DMA and simulator hardware.
   * 
   */
  virtual void reset() = 0;

  /**
   * Ensure the HW is calibrated with the clock signals.
   * 
   */
  virtual void calibrate() = 0;

  /**
   * Enables the simulator output.
   * 
   */
  virtual void enable() = 0;

  /**
   * Enables the MTI simulator output.
   * 
   */
  virtual void enableMti() = 0;

  /**
   * Enables the NORM simulator output.
   * 
   */
  virtual void enableNorm() = 0;

  /**
   * Disables the simulator output.
   * 
   */
  virtual void disable() = 0;

  /**
   * Disables the MTI simulator output.
   * 
   */
  virtual void disableMti() = 0;

  /**
   * Disables the NORM simulator output.
   * 
   */
  virtual void disableNorm() = 0;

  /**
   * Loads the clutter and target map data from the common location.
   * 
   * 
   * @param arpPosition
   */
  virtual void loadMap(const int32_t arpPosition) = 0;

  /**
   * Returns the state of the simulator.
   * 
   */
  virtual void getState(SimState& _return) = 0;
};

class SimulatorIfFactory {
 public:
  typedef SimulatorIf Handler;

  virtual ~SimulatorIfFactory() {}

  virtual SimulatorIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(SimulatorIf* /* handler */) = 0;
};

class SimulatorIfSingletonFactory : virtual public SimulatorIfFactory {
 public:
  SimulatorIfSingletonFactory(const boost::shared_ptr<SimulatorIf>& iface) : iface_(iface) {}
  virtual ~SimulatorIfSingletonFactory() {}

  virtual SimulatorIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(SimulatorIf* /* handler */) {}

 protected:
  boost::shared_ptr<SimulatorIf> iface_;
};

class SimulatorNull : virtual public SimulatorIf {
 public:
  virtual ~SimulatorNull() {}
  void reset() {
    return;
  }
  void calibrate() {
    return;
  }
  void enable() {
    return;
  }
  void enableMti() {
    return;
  }
  void enableNorm() {
    return;
  }
  void disable() {
    return;
  }
  void disableMti() {
    return;
  }
  void disableNorm() {
    return;
  }
  void loadMap(const int32_t /* arpPosition */) {
    return;
  }
  void getState(SimState& /* _return */) {
    return;
  }
};


class Simulator_reset_args {
 public:

  Simulator_reset_args(const Simulator_reset_args&);
  Simulator_reset_args& operator=(const Simulator_reset_args&);
  Simulator_reset_args() {
  }

  virtual ~Simulator_reset_args() throw();

  bool operator == (const Simulator_reset_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_reset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_reset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_reset_pargs {
 public:


  virtual ~Simulator_reset_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_reset_result {
 public:

  Simulator_reset_result(const Simulator_reset_result&);
  Simulator_reset_result& operator=(const Simulator_reset_result&);
  Simulator_reset_result() {
  }

  virtual ~Simulator_reset_result() throw();

  bool operator == (const Simulator_reset_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_reset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_reset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_reset_presult {
 public:


  virtual ~Simulator_reset_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_calibrate_args {
 public:

  Simulator_calibrate_args(const Simulator_calibrate_args&);
  Simulator_calibrate_args& operator=(const Simulator_calibrate_args&);
  Simulator_calibrate_args() {
  }

  virtual ~Simulator_calibrate_args() throw();

  bool operator == (const Simulator_calibrate_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_calibrate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_calibrate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_calibrate_pargs {
 public:


  virtual ~Simulator_calibrate_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_calibrate_result {
 public:

  Simulator_calibrate_result(const Simulator_calibrate_result&);
  Simulator_calibrate_result& operator=(const Simulator_calibrate_result&);
  Simulator_calibrate_result() {
  }

  virtual ~Simulator_calibrate_result() throw();

  bool operator == (const Simulator_calibrate_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_calibrate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_calibrate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_calibrate_presult {
 public:


  virtual ~Simulator_calibrate_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_enable_args {
 public:

  Simulator_enable_args(const Simulator_enable_args&);
  Simulator_enable_args& operator=(const Simulator_enable_args&);
  Simulator_enable_args() {
  }

  virtual ~Simulator_enable_args() throw();

  bool operator == (const Simulator_enable_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_enable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_enable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_enable_pargs {
 public:


  virtual ~Simulator_enable_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Simulator_enable_result__isset {
  _Simulator_enable_result__isset() : rsnc(false), d(false) {}
  bool rsnc :1;
  bool d :1;
} _Simulator_enable_result__isset;

class Simulator_enable_result {
 public:

  Simulator_enable_result(const Simulator_enable_result&);
  Simulator_enable_result& operator=(const Simulator_enable_result&);
  Simulator_enable_result() {
  }

  virtual ~Simulator_enable_result() throw();
  RadarSignalNotCalibratedException rsnc;
  DmaNotInitializedException d;

  _Simulator_enable_result__isset __isset;

  void __set_rsnc(const RadarSignalNotCalibratedException& val);

  void __set_d(const DmaNotInitializedException& val);

  bool operator == (const Simulator_enable_result & rhs) const
  {
    if (!(rsnc == rhs.rsnc))
      return false;
    if (!(d == rhs.d))
      return false;
    return true;
  }
  bool operator != (const Simulator_enable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_enable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Simulator_enable_presult__isset {
  _Simulator_enable_presult__isset() : rsnc(false), d(false) {}
  bool rsnc :1;
  bool d :1;
} _Simulator_enable_presult__isset;

class Simulator_enable_presult {
 public:


  virtual ~Simulator_enable_presult() throw();
  RadarSignalNotCalibratedException rsnc;
  DmaNotInitializedException d;

  _Simulator_enable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_enableMti_args {
 public:

  Simulator_enableMti_args(const Simulator_enableMti_args&);
  Simulator_enableMti_args& operator=(const Simulator_enableMti_args&);
  Simulator_enableMti_args() {
  }

  virtual ~Simulator_enableMti_args() throw();

  bool operator == (const Simulator_enableMti_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_enableMti_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_enableMti_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_enableMti_pargs {
 public:


  virtual ~Simulator_enableMti_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_enableMti_result {
 public:

  Simulator_enableMti_result(const Simulator_enableMti_result&);
  Simulator_enableMti_result& operator=(const Simulator_enableMti_result&);
  Simulator_enableMti_result() {
  }

  virtual ~Simulator_enableMti_result() throw();

  bool operator == (const Simulator_enableMti_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_enableMti_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_enableMti_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_enableMti_presult {
 public:


  virtual ~Simulator_enableMti_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_enableNorm_args {
 public:

  Simulator_enableNorm_args(const Simulator_enableNorm_args&);
  Simulator_enableNorm_args& operator=(const Simulator_enableNorm_args&);
  Simulator_enableNorm_args() {
  }

  virtual ~Simulator_enableNorm_args() throw();

  bool operator == (const Simulator_enableNorm_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_enableNorm_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_enableNorm_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_enableNorm_pargs {
 public:


  virtual ~Simulator_enableNorm_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_enableNorm_result {
 public:

  Simulator_enableNorm_result(const Simulator_enableNorm_result&);
  Simulator_enableNorm_result& operator=(const Simulator_enableNorm_result&);
  Simulator_enableNorm_result() {
  }

  virtual ~Simulator_enableNorm_result() throw();

  bool operator == (const Simulator_enableNorm_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_enableNorm_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_enableNorm_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_enableNorm_presult {
 public:


  virtual ~Simulator_enableNorm_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_disable_args {
 public:

  Simulator_disable_args(const Simulator_disable_args&);
  Simulator_disable_args& operator=(const Simulator_disable_args&);
  Simulator_disable_args() {
  }

  virtual ~Simulator_disable_args() throw();

  bool operator == (const Simulator_disable_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_disable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_disable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disable_pargs {
 public:


  virtual ~Simulator_disable_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disable_result {
 public:

  Simulator_disable_result(const Simulator_disable_result&);
  Simulator_disable_result& operator=(const Simulator_disable_result&);
  Simulator_disable_result() {
  }

  virtual ~Simulator_disable_result() throw();

  bool operator == (const Simulator_disable_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_disable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_disable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disable_presult {
 public:


  virtual ~Simulator_disable_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_disableMti_args {
 public:

  Simulator_disableMti_args(const Simulator_disableMti_args&);
  Simulator_disableMti_args& operator=(const Simulator_disableMti_args&);
  Simulator_disableMti_args() {
  }

  virtual ~Simulator_disableMti_args() throw();

  bool operator == (const Simulator_disableMti_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_disableMti_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_disableMti_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disableMti_pargs {
 public:


  virtual ~Simulator_disableMti_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disableMti_result {
 public:

  Simulator_disableMti_result(const Simulator_disableMti_result&);
  Simulator_disableMti_result& operator=(const Simulator_disableMti_result&);
  Simulator_disableMti_result() {
  }

  virtual ~Simulator_disableMti_result() throw();

  bool operator == (const Simulator_disableMti_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_disableMti_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_disableMti_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disableMti_presult {
 public:


  virtual ~Simulator_disableMti_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_disableNorm_args {
 public:

  Simulator_disableNorm_args(const Simulator_disableNorm_args&);
  Simulator_disableNorm_args& operator=(const Simulator_disableNorm_args&);
  Simulator_disableNorm_args() {
  }

  virtual ~Simulator_disableNorm_args() throw();

  bool operator == (const Simulator_disableNorm_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_disableNorm_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_disableNorm_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disableNorm_pargs {
 public:


  virtual ~Simulator_disableNorm_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disableNorm_result {
 public:

  Simulator_disableNorm_result(const Simulator_disableNorm_result&);
  Simulator_disableNorm_result& operator=(const Simulator_disableNorm_result&);
  Simulator_disableNorm_result() {
  }

  virtual ~Simulator_disableNorm_result() throw();

  bool operator == (const Simulator_disableNorm_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_disableNorm_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_disableNorm_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_disableNorm_presult {
 public:


  virtual ~Simulator_disableNorm_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Simulator_loadMap_args__isset {
  _Simulator_loadMap_args__isset() : arpPosition(false) {}
  bool arpPosition :1;
} _Simulator_loadMap_args__isset;

class Simulator_loadMap_args {
 public:

  Simulator_loadMap_args(const Simulator_loadMap_args&);
  Simulator_loadMap_args& operator=(const Simulator_loadMap_args&);
  Simulator_loadMap_args() : arpPosition(0) {
  }

  virtual ~Simulator_loadMap_args() throw();
  int32_t arpPosition;

  _Simulator_loadMap_args__isset __isset;

  void __set_arpPosition(const int32_t val);

  bool operator == (const Simulator_loadMap_args & rhs) const
  {
    if (!(arpPosition == rhs.arpPosition))
      return false;
    return true;
  }
  bool operator != (const Simulator_loadMap_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_loadMap_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_loadMap_pargs {
 public:


  virtual ~Simulator_loadMap_pargs() throw();
  const int32_t* arpPosition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Simulator_loadMap_result__isset {
  _Simulator_loadMap_result__isset() : rsnc(false) {}
  bool rsnc :1;
} _Simulator_loadMap_result__isset;

class Simulator_loadMap_result {
 public:

  Simulator_loadMap_result(const Simulator_loadMap_result&);
  Simulator_loadMap_result& operator=(const Simulator_loadMap_result&);
  Simulator_loadMap_result() {
  }

  virtual ~Simulator_loadMap_result() throw();
  IncompatibleFileException rsnc;

  _Simulator_loadMap_result__isset __isset;

  void __set_rsnc(const IncompatibleFileException& val);

  bool operator == (const Simulator_loadMap_result & rhs) const
  {
    if (!(rsnc == rhs.rsnc))
      return false;
    return true;
  }
  bool operator != (const Simulator_loadMap_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_loadMap_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Simulator_loadMap_presult__isset {
  _Simulator_loadMap_presult__isset() : rsnc(false) {}
  bool rsnc :1;
} _Simulator_loadMap_presult__isset;

class Simulator_loadMap_presult {
 public:


  virtual ~Simulator_loadMap_presult() throw();
  IncompatibleFileException rsnc;

  _Simulator_loadMap_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Simulator_getState_args {
 public:

  Simulator_getState_args(const Simulator_getState_args&);
  Simulator_getState_args& operator=(const Simulator_getState_args&);
  Simulator_getState_args() {
  }

  virtual ~Simulator_getState_args() throw();

  bool operator == (const Simulator_getState_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Simulator_getState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_getState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Simulator_getState_pargs {
 public:


  virtual ~Simulator_getState_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Simulator_getState_result__isset {
  _Simulator_getState_result__isset() : success(false) {}
  bool success :1;
} _Simulator_getState_result__isset;

class Simulator_getState_result {
 public:

  Simulator_getState_result(const Simulator_getState_result&);
  Simulator_getState_result& operator=(const Simulator_getState_result&);
  Simulator_getState_result() {
  }

  virtual ~Simulator_getState_result() throw();
  SimState success;

  _Simulator_getState_result__isset __isset;

  void __set_success(const SimState& val);

  bool operator == (const Simulator_getState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Simulator_getState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simulator_getState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Simulator_getState_presult__isset {
  _Simulator_getState_presult__isset() : success(false) {}
  bool success :1;
} _Simulator_getState_presult__isset;

class Simulator_getState_presult {
 public:


  virtual ~Simulator_getState_presult() throw();
  SimState* success;

  _Simulator_getState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class SimulatorClient : virtual public SimulatorIf {
 public:
  SimulatorClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  SimulatorClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void reset();
  void send_reset();
  void recv_reset();
  void calibrate();
  void send_calibrate();
  void recv_calibrate();
  void enable();
  void send_enable();
  void recv_enable();
  void enableMti();
  void send_enableMti();
  void recv_enableMti();
  void enableNorm();
  void send_enableNorm();
  void recv_enableNorm();
  void disable();
  void send_disable();
  void recv_disable();
  void disableMti();
  void send_disableMti();
  void recv_disableMti();
  void disableNorm();
  void send_disableNorm();
  void recv_disableNorm();
  void loadMap(const int32_t arpPosition);
  void send_loadMap(const int32_t arpPosition);
  void recv_loadMap();
  void getState(SimState& _return);
  void send_getState();
  void recv_getState(SimState& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class SimulatorProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<SimulatorIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (SimulatorProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_calibrate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_enable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_enableMti(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_enableNorm(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disableMti(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disableNorm(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_loadMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  SimulatorProcessor(boost::shared_ptr<SimulatorIf> iface) :
    iface_(iface) {
    processMap_["reset"] = &SimulatorProcessor::process_reset;
    processMap_["calibrate"] = &SimulatorProcessor::process_calibrate;
    processMap_["enable"] = &SimulatorProcessor::process_enable;
    processMap_["enableMti"] = &SimulatorProcessor::process_enableMti;
    processMap_["enableNorm"] = &SimulatorProcessor::process_enableNorm;
    processMap_["disable"] = &SimulatorProcessor::process_disable;
    processMap_["disableMti"] = &SimulatorProcessor::process_disableMti;
    processMap_["disableNorm"] = &SimulatorProcessor::process_disableNorm;
    processMap_["loadMap"] = &SimulatorProcessor::process_loadMap;
    processMap_["getState"] = &SimulatorProcessor::process_getState;
  }

  virtual ~SimulatorProcessor() {}
};

class SimulatorProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  SimulatorProcessorFactory(const ::boost::shared_ptr< SimulatorIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< SimulatorIfFactory > handlerFactory_;
};

class SimulatorMultiface : virtual public SimulatorIf {
 public:
  SimulatorMultiface(std::vector<boost::shared_ptr<SimulatorIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~SimulatorMultiface() {}
 protected:
  std::vector<boost::shared_ptr<SimulatorIf> > ifaces_;
  SimulatorMultiface() {}
  void add(boost::shared_ptr<SimulatorIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void reset() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->reset();
    }
    ifaces_[i]->reset();
  }

  void calibrate() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->calibrate();
    }
    ifaces_[i]->calibrate();
  }

  void enable() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enable();
    }
    ifaces_[i]->enable();
  }

  void enableMti() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enableMti();
    }
    ifaces_[i]->enableMti();
  }

  void enableNorm() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enableNorm();
    }
    ifaces_[i]->enableNorm();
  }

  void disable() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disable();
    }
    ifaces_[i]->disable();
  }

  void disableMti() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disableMti();
    }
    ifaces_[i]->disableMti();
  }

  void disableNorm() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disableNorm();
    }
    ifaces_[i]->disableNorm();
  }

  void loadMap(const int32_t arpPosition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->loadMap(arpPosition);
    }
    ifaces_[i]->loadMap(arpPosition);
  }

  void getState(SimState& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getState(_return);
    }
    ifaces_[i]->getState(_return);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class SimulatorConcurrentClient : virtual public SimulatorIf {
 public:
  SimulatorConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  SimulatorConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void reset();
  int32_t send_reset();
  void recv_reset(const int32_t seqid);
  void calibrate();
  int32_t send_calibrate();
  void recv_calibrate(const int32_t seqid);
  void enable();
  int32_t send_enable();
  void recv_enable(const int32_t seqid);
  void enableMti();
  int32_t send_enableMti();
  void recv_enableMti(const int32_t seqid);
  void enableNorm();
  int32_t send_enableNorm();
  void recv_enableNorm(const int32_t seqid);
  void disable();
  int32_t send_disable();
  void recv_disable(const int32_t seqid);
  void disableMti();
  int32_t send_disableMti();
  void recv_disableMti(const int32_t seqid);
  void disableNorm();
  int32_t send_disableNorm();
  void recv_disableNorm(const int32_t seqid);
  void loadMap(const int32_t arpPosition);
  int32_t send_loadMap(const int32_t arpPosition);
  void recv_loadMap(const int32_t seqid);
  void getState(SimState& _return);
  int32_t send_getState();
  void recv_getState(SimState& _return, const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

}}} // namespace

#endif
