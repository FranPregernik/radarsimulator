/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "sim_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace hr { namespace franp { namespace rsim {

int _kSubSystemValues[] = {
  SubSystem::CLUTTER,
  SubSystem::MOVING_TARGET
};
const char* _kSubSystemNames[] = {
  "CLUTTER",
  "MOVING_TARGET"
};
const std::map<int, const char*> _SubSystem_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSubSystemValues, _kSubSystemNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


SimState::~SimState() throw() {
}


void SimState::__set_time(const int32_t val) {
  this->time = val;
}

void SimState::__set_enabled(const bool val) {
  this->enabled = val;
}

void SimState::__set_mtiEnabled(const bool val) {
  this->mtiEnabled = val;
}

void SimState::__set_normEnabled(const bool val) {
  this->normEnabled = val;
}

void SimState::__set_calibrated(const bool val) {
  this->calibrated = val;
}

void SimState::__set_arpUs(const int32_t val) {
  this->arpUs = val;
}

void SimState::__set_acpCnt(const int32_t val) {
  this->acpCnt = val;
}

void SimState::__set_trigUs(const int32_t val) {
  this->trigUs = val;
}

void SimState::__set_simAcpIdx(const int32_t val) {
  this->simAcpIdx = val;
}

void SimState::__set_currAcpIdx(const int32_t val) {
  this->currAcpIdx = val;
}

void SimState::__set_loadedClutterAcpIndex(const int32_t val) {
  this->loadedClutterAcpIndex = val;
}

void SimState::__set_loadedTargetAcpIndex(const int32_t val) {
  this->loadedTargetAcpIndex = val;
}

void SimState::__set_loadedClutterAcp(const int32_t val) {
  this->loadedClutterAcp = val;
}

void SimState::__set_loadedTargetAcp(const int32_t val) {
  this->loadedTargetAcp = val;
}

uint32_t SimState::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->mtiEnabled);
          this->__isset.mtiEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->normEnabled);
          this->__isset.normEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->calibrated);
          this->__isset.calibrated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->arpUs);
          this->__isset.arpUs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->acpCnt);
          this->__isset.acpCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->trigUs);
          this->__isset.trigUs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->simAcpIdx);
          this->__isset.simAcpIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->currAcpIdx);
          this->__isset.currAcpIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->loadedClutterAcpIndex);
          this->__isset.loadedClutterAcpIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->loadedTargetAcpIndex);
          this->__isset.loadedTargetAcpIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->loadedClutterAcp);
          this->__isset.loadedClutterAcp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->loadedTargetAcp);
          this->__isset.loadedTargetAcp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SimState");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mtiEnabled", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->mtiEnabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("normEnabled", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->normEnabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("calibrated", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->calibrated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arpUs", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->arpUs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acpCnt", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->acpCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trigUs", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->trigUs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("simAcpIdx", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->simAcpIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currAcpIdx", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->currAcpIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loadedClutterAcpIndex", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->loadedClutterAcpIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loadedTargetAcpIndex", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->loadedTargetAcpIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loadedClutterAcp", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->loadedClutterAcp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loadedTargetAcp", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->loadedTargetAcp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimState &a, SimState &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.enabled, b.enabled);
  swap(a.mtiEnabled, b.mtiEnabled);
  swap(a.normEnabled, b.normEnabled);
  swap(a.calibrated, b.calibrated);
  swap(a.arpUs, b.arpUs);
  swap(a.acpCnt, b.acpCnt);
  swap(a.trigUs, b.trigUs);
  swap(a.simAcpIdx, b.simAcpIdx);
  swap(a.currAcpIdx, b.currAcpIdx);
  swap(a.loadedClutterAcpIndex, b.loadedClutterAcpIndex);
  swap(a.loadedTargetAcpIndex, b.loadedTargetAcpIndex);
  swap(a.loadedClutterAcp, b.loadedClutterAcp);
  swap(a.loadedTargetAcp, b.loadedTargetAcp);
  swap(a.__isset, b.__isset);
}

SimState::SimState(const SimState& other0) {
  time = other0.time;
  enabled = other0.enabled;
  mtiEnabled = other0.mtiEnabled;
  normEnabled = other0.normEnabled;
  calibrated = other0.calibrated;
  arpUs = other0.arpUs;
  acpCnt = other0.acpCnt;
  trigUs = other0.trigUs;
  simAcpIdx = other0.simAcpIdx;
  currAcpIdx = other0.currAcpIdx;
  loadedClutterAcpIndex = other0.loadedClutterAcpIndex;
  loadedTargetAcpIndex = other0.loadedTargetAcpIndex;
  loadedClutterAcp = other0.loadedClutterAcp;
  loadedTargetAcp = other0.loadedTargetAcp;
  __isset = other0.__isset;
}
SimState& SimState::operator=(const SimState& other1) {
  time = other1.time;
  enabled = other1.enabled;
  mtiEnabled = other1.mtiEnabled;
  normEnabled = other1.normEnabled;
  calibrated = other1.calibrated;
  arpUs = other1.arpUs;
  acpCnt = other1.acpCnt;
  trigUs = other1.trigUs;
  simAcpIdx = other1.simAcpIdx;
  currAcpIdx = other1.currAcpIdx;
  loadedClutterAcpIndex = other1.loadedClutterAcpIndex;
  loadedTargetAcpIndex = other1.loadedTargetAcpIndex;
  loadedClutterAcp = other1.loadedClutterAcp;
  loadedTargetAcp = other1.loadedTargetAcp;
  __isset = other1.__isset;
  return *this;
}
void SimState::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SimState(";
  out << "time=" << to_string(time);
  out << ", " << "enabled=" << to_string(enabled);
  out << ", " << "mtiEnabled=" << to_string(mtiEnabled);
  out << ", " << "normEnabled=" << to_string(normEnabled);
  out << ", " << "calibrated=" << to_string(calibrated);
  out << ", " << "arpUs=" << to_string(arpUs);
  out << ", " << "acpCnt=" << to_string(acpCnt);
  out << ", " << "trigUs=" << to_string(trigUs);
  out << ", " << "simAcpIdx=" << to_string(simAcpIdx);
  out << ", " << "currAcpIdx=" << to_string(currAcpIdx);
  out << ", " << "loadedClutterAcpIndex=" << to_string(loadedClutterAcpIndex);
  out << ", " << "loadedTargetAcpIndex=" << to_string(loadedTargetAcpIndex);
  out << ", " << "loadedClutterAcp=" << to_string(loadedClutterAcp);
  out << ", " << "loadedTargetAcp=" << to_string(loadedTargetAcp);
  out << ")";
}


RadarSignalNotCalibratedException::~RadarSignalNotCalibratedException() throw() {
}


uint32_t RadarSignalNotCalibratedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RadarSignalNotCalibratedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RadarSignalNotCalibratedException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RadarSignalNotCalibratedException &a, RadarSignalNotCalibratedException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

RadarSignalNotCalibratedException::RadarSignalNotCalibratedException(const RadarSignalNotCalibratedException& other2) : TException() {
  (void) other2;
}
RadarSignalNotCalibratedException& RadarSignalNotCalibratedException::operator=(const RadarSignalNotCalibratedException& other3) {
  (void) other3;
  return *this;
}
void RadarSignalNotCalibratedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RadarSignalNotCalibratedException(";
  out << ")";
}

const char* RadarSignalNotCalibratedException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: RadarSignalNotCalibratedException";
  }
}


IncompatibleFileException::~IncompatibleFileException() throw() {
}


void IncompatibleFileException::__set_subSystem(const SubSystem::type val) {
  this->subSystem = val;
}

uint32_t IncompatibleFileException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->subSystem = (SubSystem::type)ecast4;
          this->__isset.subSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IncompatibleFileException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IncompatibleFileException");

  xfer += oprot->writeFieldBegin("subSystem", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->subSystem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IncompatibleFileException &a, IncompatibleFileException &b) {
  using ::std::swap;
  swap(a.subSystem, b.subSystem);
  swap(a.__isset, b.__isset);
}

IncompatibleFileException::IncompatibleFileException(const IncompatibleFileException& other5) : TException() {
  subSystem = other5.subSystem;
  __isset = other5.__isset;
}
IncompatibleFileException& IncompatibleFileException::operator=(const IncompatibleFileException& other6) {
  subSystem = other6.subSystem;
  __isset = other6.__isset;
  return *this;
}
void IncompatibleFileException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IncompatibleFileException(";
  out << "subSystem=" << to_string(subSystem);
  out << ")";
}

const char* IncompatibleFileException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: IncompatibleFileException";
  }
}


DmaNotInitializedException::~DmaNotInitializedException() throw() {
}


void DmaNotInitializedException::__set_subSystem(const SubSystem::type val) {
  this->subSystem = val;
}

uint32_t DmaNotInitializedException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->subSystem = (SubSystem::type)ecast7;
          this->__isset.subSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DmaNotInitializedException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DmaNotInitializedException");

  xfer += oprot->writeFieldBegin("subSystem", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->subSystem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DmaNotInitializedException &a, DmaNotInitializedException &b) {
  using ::std::swap;
  swap(a.subSystem, b.subSystem);
  swap(a.__isset, b.__isset);
}

DmaNotInitializedException::DmaNotInitializedException(const DmaNotInitializedException& other8) : TException() {
  subSystem = other8.subSystem;
  __isset = other8.__isset;
}
DmaNotInitializedException& DmaNotInitializedException::operator=(const DmaNotInitializedException& other9) {
  subSystem = other9.subSystem;
  __isset = other9.__isset;
  return *this;
}
void DmaNotInitializedException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DmaNotInitializedException(";
  out << "subSystem=" << to_string(subSystem);
  out << ")";
}

const char* DmaNotInitializedException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: DmaNotInitializedException";
  }
}

}}} // namespace
